package com.ivan.alkemybackendchallenge.feature.resource;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.ivan.alkemybackendchallenge.feature.dto.data.MediaGenreDto;
import com.ivan.alkemybackendchallenge.feature.utility.FeatureConstants;
import com.ivan.alkemybackendchallenge.security.dto.data.ErrorResponseBodyDto;
import com.ivan.alkemybackendchallenge.security.service.JwtServiceImpl;
import com.ivan.alkemybackendchallenge.security.utility.SecurityConstants;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.HttpStatus;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Assertions.assertNotNull;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)
class MediaGenreControllerIntegrationTest {

    private final RestTemplate restTemplate;
    private final String absoluteURL = "http://localhost:8080/genres";
    private final String MOCK_AUTH_HEADER_NAME = "Authorization";
    private final String MOCK_AUTH_HEADER_VALUE;
    private Map<String, String> validGenreToCreateForm;

    @Autowired
    MediaGenreControllerIntegrationTest(RestTemplateBuilder restTemplateBuilder) {
        this.restTemplate = restTemplateBuilder.build();
        String token = new JwtServiceImpl().createAccessToken(
                SecurityConstants.TEST_USER_USERNAME,
                Arrays.asList(SecurityConstants.DEFAULT_USER_ROLE),
                "http://localhost:8080/auth/login"
        );
        this.MOCK_AUTH_HEADER_VALUE = "Bearer " + token;
    }

    /**
     * Generates a map with valid attributes to create a new MediaGenre.
     *
     * The keys have the same names as the attributes from the class MediaGenreDto.
     */
    @BeforeEach
    private void initGenreToCreateForm() {
        this.validGenreToCreateForm = new HashMap<>();
        validGenreToCreateForm.put("name", "Action");
        validGenreToCreateForm.put("imageUrl", "https://upload.wikimedia.org/wikipedia/commons/thumb/b/bf/Action_film_clapperboard.svg/200px-Action_film_clapperboard.svg.png");
    }

    @Test
    @DisplayName("Valid genre creation case")
    void createGenreTest() {
        ResponseEntity<MediaGenreDto> result = restTemplate.postForEntity(
                this.absoluteURL,
                RequestEntity.post(FeatureConstants.Endpoint.MEDIA_GENRE)
                        .header(this.MOCK_AUTH_HEADER_NAME, this.MOCK_AUTH_HEADER_VALUE)
                        .body(this.validGenreToCreateForm),
                MediaGenreDto.class
        );
        assertEquals(HttpStatus.CREATED.value(), result.getStatusCode().value(), "Response status is CREATED");
        assertNotNull(result.getBody(), "Response body is present");
        assertEquals(this.validGenreToCreateForm.get("name").toLowerCase(), result.getBody().getName(), "Entity with the same name was stored and returned");
        assertNull(this.validGenreToCreateForm.get("id"), "id attribute wasn't sent in the request.");
        assertNotNull(result.getBody().getId(), "Id attribute is present in the response (generated by the server)");
    }

    @Test
    @DisplayName("Length of the genre's name exceeds the limit.")
    void createGenreIllegalParamTest() {
        String longName = Stream.generate(() -> "a")
                .limit(FeatureConstants.GENRE_NAME_LENGTH + 1)
                .collect(Collectors.joining());
        assertTrue(longName.length() > FeatureConstants.GENRE_NAME_LENGTH, "The name exceeds the size limit");
        this.validGenreToCreateForm.replace("name", longName);

        ResponseEntity<MediaGenreDto>  validResult = null;
        ErrorResponseBodyDto resultError = null;

        try {

            validResult = restTemplate.postForEntity(
                    this.absoluteURL,
                    RequestEntity.post(FeatureConstants.Endpoint.MEDIA_GENRE)
                            .header(this.MOCK_AUTH_HEADER_NAME, this.MOCK_AUTH_HEADER_VALUE)
                            .body(this.validGenreToCreateForm),
                    MediaGenreDto.class
            );

        } catch (HttpClientErrorException e) {

            String responseBodyAsString = e.getResponseBodyAsString();
            ObjectMapper objectMapper = new ObjectMapper();
            try {
                resultError = objectMapper.readValue(responseBodyAsString, ErrorResponseBodyDto.class);
            } catch (JsonProcessingException e2) {
                // resultError is left as null to be handled with the first assert.
            }

        }

        assertNull(validResult, "The method call was interrupted, so the normal result is null.");
        assertNotNull(resultError, "Exception launched, caught by CustomResponseEntityExceptionHandler, error response obtained and mapped");
        assertEquals(HttpStatus.BAD_REQUEST.value(), Integer.parseInt(resultError.getStatus()), "Response status is BAD_REQUEST");
        assertEquals("Genre name too long (" + FeatureConstants.GENRE_NAME_LENGTH + " characters max)", resultError.getMessage(), "Error message is correct");
    }

    @Test
    @DisplayName("Mandatory genre attribute missing.")
    void createGenreMissingParamTest() {
        // NAME PARAM MISSING TEST
        this.validGenreToCreateForm.remove("name");
        assertNull(this.validGenreToCreateForm.get("name"), "name attribute removed from the request body");

        ResponseEntity<MediaGenreDto>  validResult = null;
        ErrorResponseBodyDto resultError = null;

        try {

            validResult = restTemplate.postForEntity(
                    this.absoluteURL,
                    RequestEntity.post(FeatureConstants.Endpoint.MEDIA_GENRE)
                            .header(this.MOCK_AUTH_HEADER_NAME, this.MOCK_AUTH_HEADER_VALUE)
                            .body(this.validGenreToCreateForm),
                    MediaGenreDto.class
            );

        } catch (HttpClientErrorException e) {

            String responseBodyAsString = e.getResponseBodyAsString();
            ObjectMapper objectMapper = new ObjectMapper();
            try {
                resultError = objectMapper.readValue(responseBodyAsString, ErrorResponseBodyDto.class);
            } catch (JsonProcessingException e2) {
                // resultError is left as null to be handled with the first assert.
            }

        }

        assertNull(validResult, "The method call was interrupted, so the normal result is null.");
        assertNotNull(resultError, "Exception launched, caught by CustomResponseEntityExceptionHandler, error response obtained and mapped");
        assertEquals(HttpStatus.BAD_REQUEST.value(), Integer.parseInt(resultError.getStatus()), "Response status is BAD_REQUEST");
        assertEquals("Genre name not provided", resultError.getMessage(), "Error message is correct");
    }

    @Test
    @DisplayName("Name already taken")
    void createGenreAlreadyExistsTest() {
        final String genreNameThatAlreadyExists = "comedy";
        this.validGenreToCreateForm.replace("name", genreNameThatAlreadyExists);

        ResponseEntity<MediaGenreDto>  validResult = null;
        ErrorResponseBodyDto resultError = null;

        try {

            validResult = restTemplate.postForEntity(
                    this.absoluteURL,
                    RequestEntity.post(FeatureConstants.Endpoint.MEDIA_GENRE)
                            .header(this.MOCK_AUTH_HEADER_NAME, this.MOCK_AUTH_HEADER_VALUE)
                            .body(this.validGenreToCreateForm),
                    MediaGenreDto.class
            );

        } catch (HttpClientErrorException e) {

            String responseBodyAsString = e.getResponseBodyAsString();
            ObjectMapper objectMapper = new ObjectMapper();
            try {
                resultError = objectMapper.readValue(responseBodyAsString, ErrorResponseBodyDto.class);
            } catch (JsonProcessingException e2) {
                // resultError is left as null to be handled with the first assert.
            }

        }

        assertNull(validResult, "The method call was interrupted, so the normal result is null.");
        assertNotNull(resultError, "Exception launched, caught by CustomResponseEntityExceptionHandler, error response obtained and mapped");
        assertEquals(HttpStatus.CONFLICT.value(), Integer.parseInt(resultError.getStatus()), "Response status is CONFLICT");
        assertEquals("Genre "+ genreNameThatAlreadyExists +" already exists", resultError.getMessage(), "Error message is correct");
    }

}